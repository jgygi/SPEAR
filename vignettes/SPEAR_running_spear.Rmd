---
title: "SPEAR: Running SPEAR"
author: "Jeremy Gygi"
date: "1/26/21"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SPEAR-running_SPEAR}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

### This vignette will provide a walkthrough for using SPEAR on multi-omic data.

##### Installing SPEAR:

```{r}
# Set up the path to the downladed tar.gz package:
#path_to_SPEAR_tar.gz <- "~/Dropbox/shared_folder/SPEARcomplete_1.0.tar.gz"

# Run this command to install the SPEARcomplete (SPEAR) package
#install.packages(path_to_SPEAR_tar.gz, repos = NULL, type="source")

# If this fails, you may need to install these packages:
#install.packages('BH')
#install.packages('Rcpp')
#install.packages('RcppArmadillo')
#install.packages('glmnet')
```

##### Required Libraries:

```{r}
# Required Packages for SPEAR:
library(SPEARcomplete)
library(glmnet)
library(parallel)

# Recommended Packages (for downstream analysis):
library(jsonlite)
library(dplyr)
library(reshape2)
library(stringr)
library(ggplot2)
library(cowplot)

```

### Loading the multi-omic data:

![Data preparation for SPEAR](vignette_xysetup.png){width=80%}

Loading your own multi-omic data:

```{r}
# Parameters:
# X - a list of matrices of omics data [subjects = rows, features = columns] (i.e. OmicsData 1 would be X[[1]], ...)
# Y - a matrix of response data [subjects = rows, response.variables = columns] (i.e. Response1 would be Y[,1], ...)
# 
# Data should be scaled/standardized (mean = 0, variance = 1) before using SPEAR:

X <- NULL # Replace with your list of matrices...
Y <- NULL # Replace with your matrix...
```

Loading simulated multi-omic data: (skip this if using your own data)

```{r}
# Generated from the SPEAR_simulate_data.Rmd file:
path_to_sim_data <- "" # Replace with the path to the 'simulated_gaussian_data.rds' file
sim.data <- readRDS(paste0(path_to_sim_data, "simulated_gaussian_data.rds"))

X <- sim.data$data.tr$xlist
Y <- sim.data$data.tr$Y
```

Naming the features, subjects, and datasets (for downstream analysis):

```{r}
colnames(Y) <- "GausResponse"
rownames(Y) <- paste0("Subject", 1:nrow(Y))
names(X) <- paste0("OmicsData", 1:length(X))
for(i in 1:length(X)){
  colnames(X[[i]]) <- paste0(names(X)[i], "_feat", 1:ncol(X[[i]]))
  rownames(X[[i]]) <- paste0("Subject", 1:nrow(X[[i]]))
}

# Make sure the subjects (rows) are consistent across X and Y
all(rownames(Y) == rownames(X[[1]]))
```

##### Running SPEAR:

```{r}
# Run the cv version of SPEAR
#    Main Parameters:
# X - Omics datasets (as list of matrices). Rows = subjects, columns = features
# Y - Response (as matrix). Rows = subjects, columns = response features
#
#    Other Parameters:
num.factors = 5 # How many factors should SPEAR generate? 5-10 should be sufficient for most cases
save.path <- getwd() # path for SPEARobject (rds file) to be saved
save.name <- "SPEAR_vignette_object.rds" # name for SPEARobject (rds file)
seed <- 123 # reproducible seed

# Running cross-validated SPEAR:
#SPEARobj <- run_cv_spear(X = X, 
#                         Y = Y, 
#                         num.factors = num.factors, 
#                         seed = seed, 
#                         save.path = save.path, 
#                         save.name = save.name,
#                         run.debug = TRUE)
# Make sure X is a list:
scale.x <- TRUE
scale.y <- TRUE
Xobs <- NULL
Yobs <- NULL
foldid <- NULL
num.folds <- 5
weights <- NULL
Z <- NULL
warmup.iterations = NULL
max.iterations = NULL
elbo.threshold = NULL
elbo.threshold.count = NULL
cv.nlambda = 100
print.out = 100
save.model = TRUE
save.path = NULL
save.name = NULL
run.debug = FALSE
inits.type <- "pca"
family <- 0
  if(scale.x){
    X.scaled <- lapply(X, scale)
  } else {
    X.scaled <- X
  }
  if(is.null(names(X.scaled))){
    cat(paste0("*** Names for datasets in X not provided. Renaming to ", paste(paste0("X", 1:length(X.scaled)), collapse = ", "), "\n"))
    names(X.scaled) <- paste0("X", 1:length(X.scaled))
  }
  for(d in 1:length(X.scaled)){
    if(is.null(colnames(X.scaled[[d]]))){
      cat(paste0("*** Feature names in ", names(X.scaled)[d], " not provided. Renaming to ", paste0(names(X.scaled)[d], "_feat", 1), " ... ", paste0(names(X.scaled)[d], "_feat", ncol(X.scaled[[d]])), "\n"))
      colnames(X.scaled[[d]]) <- paste0(names(X.scaled)[d], "_feat", 1:ncol(X.scaled[[d]]))
    }
  }
  cat(paste0("Detected ", length(X.scaled), " datasets:\n"))
  for(i in 1:length(X.scaled)){
    cat(paste0(names(X.scaled)[i], "\tSubjects: ", nrow(X.scaled[[i]]), "\tFeatures: ", ncol(X.scaled[[i]]), "\n"))
  }
  
  if(scale.y){
    Y.scaled <- scale(Y)
  } else {
    Y.scaled <- Y
  }
  if(is.null(colnames(Y.scaled))){
    cat(paste0("*** Names for response Y not provided. Renaming to ", paste(paste0("Y", 1:ncol(Y.scaled)), collapse = ", "), "\n"))
    colnames(Y.scaled) <- paste0("Y", 1:ncol(Y.scaled))
  }
  cat(paste0("Detected ", ncol(Y.scaled), " response ", ifelse(ncol(Y.scaled) == 1, "variable", "variables"), ":\n"))
  for(i in 1:ncol(Y.scaled)){
    cat(paste0(colnames(Y.scaled)[i], "\tSubjects: ", sum(!is.na(Y.scaled[,i])), "\tType: ", ifelse(family == 0, "Gaussian", "Ordinal"), "\n"))
  }
  
  
  
  
  cat("\n")
  
  # Run Preparation Function:
  data <- SPEARcomplete::preparation(Y = Y.scaled, X = X.scaled, family = family)
  data$xlist <- X.scaled
  
  # Parameters:
  cat(paste0("Preparing SPEAR parameters...\n"))
  
  # Seed:
  if(is.null(seed)){
    cat(paste0("*** seed not provided. Consider using a seed (i.e. 123) for reproducibility.\n"))
  } else {
    cat(paste0("~~~ seed set to ", seed, ".\n"))
    set.seed(seed)
  }
  # Set up matrices that indicate which samples are missing (since none are missing, just fill with 1's)
  if(is.null(Xobs)){
    cat(paste0("*** Xobs not provided. Assuming full observations in X.\n"))
    Xobs <- array(1, dim  = dim(data$X))
  }
  if(is.null(Yobs)){
    cat(paste0("*** Yobs not provided. Assuming full observations in Y.\n"))
    Yobs <- array(1, dim  = dim(data$Y))
  }
  # Assigning fold-id's to each of the N subjects in the training set:
  if(is.null(foldid)){
    cat(paste0("*** foldid not provided. Assigning folds randomly from 1 to ", num.folds, ".\n"))
    foldid = sample(1:num.folds, nrow(data$X), replace = T)
  } else {
    if(length(foldid) == nrow(data$X)){
      cat(paste0("~~~ foldid provided | passed\n"))
    } else {
      cat(paste0("~~~ foldid provided | ERROR: length(foldid) = ", length(foldid), " != Number of Subjects (", nrow(data$X), "). Cannot use provided foldids.\n"))
      stop(paste0("SPEAR preparation ERROR: length(foldid) = ", length(foldid), " != Number of Subjects (", nrow(data$X), "). Cannot use provided foldids.\n"))
    }
  }
  
  if(is.null(weights)){
    cat(paste0("*** weights not provided. Using c(2, 1.8, 1.6, 1.4, 1.2, 1.0, 0.8, 0.6, 0.4, 0.2, 0.0)\n"))
    weights <- c(2, 1.8, 1.6, 1.4, 1.2, 1.0, 0.8, 0.6, 0.4, 0.2, 0.0)
  } else {
    cat(paste0("~~~ weights - using c(", paste(round(weights, 2), collapse = ", "), ")\n"))
  }
  if(is.null(num.factors)){
    cat(paste0("*** num.factors not provided. Defaulting to K = 5 factors\n"))
    num.factors <- 5
  } else {
    cat(paste0("~~~ num.factors - using K = ", num.factors, " factors\n"))
  }
  
  if(is.null(Z)){
    Z <- data$X
  }
  
  other.params <- c("warmup", "max.iterations", "elbo.threshold", "elbo.threshold.count")
  if(is.null(warmup.iterations)){
    warm_up <- 50
  } else {
    warm_up <- warmup.iterations
  }
  if(is.null(max.iterations)){
    max_iter <- 1000
  } else {
    max_iter <- max.iterations
  }
  if(is.null(elbo.threshold)){
    thres_elbo <- 0.1
  } else {
    thres_elbo <- elbo.threshold
  }
  if(is.null(elbo.threshold.count)){
    thres_count <- 5
  } else {
    thres_count <- elbo.threshold.count
  }
  
  
  
  cat("\n*****************\n  Running SPEAR\n*****************\n\n")
  
  if(.Platform$OS.type == "windows"){
    cat(paste0("*NOTE:* Windows machine detected. SPEAR uses the mclapply function for parallelization, which is not supported on Windows.
        Consider using SPEAR on a unix operating system for boosted performance.\n"))
    numCores <- 1
  } else {
    numCores <- parallel::detectCores()
  }
spear_fit <- cv.spear(X = data$X, 
                        Y = data$Y,
                        Xobs = Xobs, 
                        Yobs = Yobs,
                        Z = Z, 
                        pattern_samples = data$pattern_samples,
                        pattern_features = data$pattern_features,
                        family = family, 
                        nclasses = data$nclasses,
                        ws = weights,
                        foldid = foldid, 
                        num_factors = num.factors,  
                        functional_path = data$functional_path,
                        print_out = print.out, 
                        inits_type = inits.type, 
                        warm_up= warm_up, 
                        max_iter = max_iter, 
                        seed = seed, 
                        thres_elbo = thres_elbo, 
                        thres_count = thres_count, 
                        crossYonly = F,
                        numCores = numCores,
                        run.debug = TRUE)

# This SPEARobj (SPEAR object) is already saved to an rds file (see SPEAR printed output for location)

# For downstream analysis, continue with SPEAR_downstream_vignette.Rmd (need a SPEARobj)
```

