Theta0 = list(); Gamma0 = list()
X = list(); Xte = list()
for(d in 1:D){
Theta0[[d]] = matrix(rnorm(P*num_factors, sd = 1), ncol = P) * c
Gamma0[[d]] = matrix(rbinom(P*num_factors, size = 1, prob  = pi), ncol = P)
}
if(num_specific != D){
print("Assigning factors to datasets:")
for(k in 1:num_factors){
ii = sample(1:D, num_specific)
print(paste0("Factor", k, ": ", paste(ii, collapse = ", ")))
for(d in 1:D){
if(!(d%in%ii)){
Gamma0[[d]][k,] = 0
Theta0[[d]] = Theta0[[d]] * Gamma0[[d]]
}
}
}
}
U0 = matrix(rnorm(N*num_factors), nrow = N)
U0te = matrix(rnorm(Ntest*num_factors), nrow = Ntest)
X = list(); Xte = list()
scale_mean.X = c(); scale_sd.X = c()
for(d in 1:D){
X[[d]] = scale(U0 %*% Theta0[[d]]+matrix(rnorm(N*P), ncol = P))
Xte[[d]] = scale(U0te %*% Theta0[[d]]+matrix(rnorm(Ntest*P), ncol = P))
tmp1 = apply(X[[d]], 2, mean);
tmp2 =  apply(X[[d]], 2, sd);
scale_mean.X =c(scale_mean.X, tmp1)
scale_sd.X = c(scale_sd.X, tmp2)
X[[d]] = t(apply(X[[d]], 1, function(z) (z - tmp1)/tmp2))
Xte[[d]] = t(apply(Xte[[d]], 1, function(z) (z - tmp1)/tmp2))
}
if(Ymodel == "factor"){
Y = rowSums(U0[,1:factors.influencing.y])*sqrt(eta/factors.influencing.y) + rnorm(N)
Yte = rowSums(U0te[,1:factors.influencing.y])* sqrt(eta/factors.influencing.y)+rnorm(Ntest)
Ytruth = rowSums(U0[,1:factors.influencing.y])*sqrt(eta/factors.influencing.y)
Ytruth_te =  rowSums(U0te[,1:factors.influencing.y])* sqrt(eta/factors.influencing.y)
}else{
Xcombine = X[[1]]
Xcombine.te = Xte[[1]]
for(d in 2:D){
Xcombine = cbind(Xcombine, X[[d]])
Xcombine.te = cbind(Xcombine.te, Xte[[d]])
}
beta =rnorm(ncol(Xcombine)) * rbinom(ncol(Xcombine), size = 1, prob = pi_reg)
beta = beta/sqrt(sum(beta^2)) * sqrt(eta)
Ytruth =  Xcombine%*%beta
Ytruth_te =  Xcombine.te%*% beta
Y = Ytruth + rnorm(N)
Yte = Ytruth_te+rnorm(Ntest)
}
scale_mean.y = mean(Y); scale_sd.y = sd(Y);
y = (Y - scale_mean.y)/scale_sd.y; yte = (Yte - scale_mean.y)/scale_sd.y;
ytruth = (Ytruth - scale_mean.y)/scale_sd.y; ytruth.te = (Ytruth_te - scale_mean.y)/scale_sd.y;
data.tr = preparation(Y = y, X = X, family = family, path.type = "assay")
data.te = preparation(Y = yte, X = Xte, family = family, path.type = "assay")
data.tr$truth = ytruth
data.tr$xlist = X
data.tr$U = U0
data.te$truth = ytruth.te
data.te$U = U0te
data.te$xlist = Xte
return(list(data.tr = data.tr, data.te = data.te))
}
# Data simulation parameters:
K = 5 # number of factors
D = 4 # number of omics datasets to simulate
N = 200 # number of subjects in the training set
P = 200 # number of features to simulate per omics dataset
c = 3 # signal-to-noise ratio. 1 is low, 3 is high
c = sqrt(c *log(P*D)/N)
Ymodel = "factor" # parameter indicating that Y (gaussian response) is generated from the factors
Ntest = 2000 # number of subjects in the testing set
num_specific = 2 # should factors be omics specific? If num_specific = D, all omics are influenced by all factors. If num_specific < D, each factor will be randomly assigned to 'num_specific' omics datasets.
factors.influencing.y = 2 # how many of the K factors should be used to influence the response?
family = 0 # When response is gaussian, use family = 0. For ordinal response, use family = 1
pi = .2 # amount of sparsity for features (P(feature having signal) = pi)
# Data Generation:
data.total = dataGen(N = N,
Ntest = Ntest,
P = P,
D = D,
iteration = NULL,
seed = seed,
num_factors = K,
c = c,
pi = pi,
eta = 1,
num_specific =num_specific,
Ymodel = Ymodel,
family = family,
factors.influencing.y = factors.influencing.y,
pi_reg = N/(P*D*log(P * D) * log(P * D)))
# Save the data to use in the SPEAR vignette:
file_path <- getwd()
saveRDS(data.total, file = paste0(file_path, "/simulated_gaussian_data.rds"))
# Required Packages for SPEAR:
library(SPEARcomplete)
library(glmnet)
library(parallel)
# Recommended Packages (for downstream analysis):
path_to_SPEARkit <- "~/Dropbox/shared_folder/SPEARkit/SPEARkit.R"
source(path_to_SPEARkit)
library(jsonlite)
library(dplyr)
library(reshape2)
library(stringr)
library(ggplot2)
library(cowplot)
# Generated from the SPEAR_simulate_data.Rmd file:
path_to_sim_data <- getwd() # Replace with the path to the 'simulated_gaussian_data.rds' file
sim.data <- readRDS(paste0(path_to_sim_data, "/simulated_gaussian_data.rds"))
X <- sim.data$data.tr$xlist
Y <- sim.data$data.tr$Y
colnames(Y) <- "GausResponse"
rownames(Y) <- paste0("Subject", 1:nrow(Y))
names(X) <- paste0("OmicsData", 1:length(X))
for(i in 1:length(X)){
colnames(X[[i]]) <- paste0(names(X)[i], "_feat", 1:ncol(X[[i]]))
rownames(X[[i]]) <- paste0("Subject", 1:nrow(X[[i]]))
}
# Make sure the subjects (rows) are consistent across X and Y
all(rownames(Y) == rownames(X[[1]]))
# Run the cv version of SPEAR
#    Main Parameters:
# X - Omics datasets (as list of matrices). Rows = subjects, columns = features
# Y - Response (as matrix). Rows = subjects, columns = response features
#
#    Other Parameters:
num.factors = 5 # How many factors should SPEAR generate? 5-10 should be sufficient for most cases
save.path <- getwd() # path for SPEARobject (rds file) to be saved
save.name <- "SPEAR_vignette_object.rds" # name for SPEARobject (rds file)
seed <- 123 # reproducible seed
# Running cross-validated SPEAR:
SPEARobj <- run_cv_spear(X = X,
Y = Y,
num.factors = num.factors,
seed = seed,
save.path = save.path,
save.name = save.name)
# This SPEARobj (SPEAR object) is already saved to an rds file (see SPEAR printed output for location)
# For downstream analysis, continue with SPEAR_downstream_vignette.Rmd (need a SPEARobj)
# Required Packages for SPEAR:
library(SPEARcomplete)
library(glmnet)
library(parallel)
# Recommended Packages (for downstream analysis):
path_to_SPEARkit <- "~/Dropbox/shared_folder/SPEARkit/SPEARkit.R"
source(path_to_SPEARkit)
library(jsonlite)
library(dplyr)
library(reshape2)
library(stringr)
library(ggplot2)
library(cowplot)
# Load in the SPEARobject saved from running SPEAR:
file.path <- getwd()
SPEARobj <- readRDS(paste0(file.path, "/SPEAR_vignette_object.rds"))
names(SPEARobj)
# Check values of 'w' (weights) used by SPEAR:
SPEARobj$params$weights
# Get best weights (w):
#      Parameters:
# include.best.overall (only useful with more than one response... if two responses perform best with different values of w, select the single w with minimized cvm for all responses)
SPEAR.get_best_weights(SPEARobj, include.best.overall = TRUE)
# Get factor contributions for each factor generated by SPEAR. Will return:
#   factor.contributions: the exact contribution amounts per factor
#   relevant.factors:     which factors are deemed "relevant" (contribution > threshold, .01 by default)
#   threshold:   the cutoff used to determine which factors are "relevant"
SPEAR.get_factor_contributions(SPEARobj, threshold = .01)
# Plot factor contributions:
#     threshold: cutoff used to determine factor relevance
#     show.irrelevant: if FALSE, will only plot relevant factor contributions
#     show.labels: show numeric contributions in plot?
SPEAR.plot_factor_contributions(SPEARobj, threshold = .01, show.irrelevant = FALSE, show.labels = TRUE)
# As a quick aside, plotting functions all return ggplot grob objects, and can be easily edited as such:
plot <- SPEAR.plot_factor_contributions(SPEARobj, threshold = .01, show.irrelevant = FALSE, show.labels = TRUE)
plot +
scale_fill_distiller(palette = "Reds", direction = 1) +
ggtitle("Custom Factor Contribution Plot")
# Get cross-validated prediction error
#    show.all.w - show cvm for all weights? Best weight is found by lowest cvm
#  (similar to SPEARobj$cv.eval$cvm)
SPEAR.get_cv_prediction_error(SPEARobj, show.all.w = TRUE)
# Plot cv predictions for the best weight:
SPEAR.plot_cv_predictions(SPEARobj)
# Get actual predictions:
#  w - which weight to use?
#  'best' will return lowest cvm per response.
#  'overall' returns the lowest cvm overall. When only measuring one response, 'best' is the same as 'overall'.
#  'all' returns a list with each prediction for each value of 'w'.
spear.predictions.best <- SPEAR.get_cv_predictions(SPEARobj, w = "best")
spear.predictions.overall <- SPEAR.get_cv_predictions(SPEARobj, w = "all")
spear.predictions.all <- SPEAR.get_cv_predictions(SPEARobj, w = "all")
print(spear.predictions.best$predictions[1:10])
# First, set up a named vector called 'groups'. Set names(groups) to be the subject for each grouping variable:
# Example of setting up a continuous 'groups' vector:
# Use the response as the variable we want to plot:
groups <- SPEARobj$data$Y
# Set the names of the vector to be the samples they correspond to (make sure they are ordered correctly)
names(groups) <- rownames(SPEARobj$data$Y)
# Plot the factor scores:
SPEAR.plot_factor_scores(SPEARobj, groups = groups)
# Lets convert the continuous response into ordinal (bins)
# Use the response as the variable we want to plot:
groups <- round(SPEARobj$data$Y, 0)
groups <- factor(as.character(groups), levels = as.character(unique(sort(groups))))
# Set the names of the vector to be the samples they correspond to (make sure they are ordered correctly)
names(groups) <- rownames(SPEARobj$data$Y)
# Plot the factor scores:
SPEAR.plot_factor_scores(SPEARobj, groups = groups)
SPEAR.plot_factor_grid(SPEARobj, groups = groups)
relevant.factors.to.Y <- which(SPEAR.get_factor_contributions(SPEARobj)$relevant.factors == 1)
SPEAR.plot_factor_grid(SPEARobj, groups = groups, factors = relevant.factors.to.Y)
# This will plot two rows of plots:
# top row - Factor Scores (X axis) vs. SPEAR CV Predictions
# bottom row - Factor Scores (X axis) vs. True response (SPEARobj$data$Y)
f.scores <- SPEAR.get_factor_scores(SPEARobj)$GausResponse$factor.scores
spear.preds <- SPEAR.get_cv_predictions(SPEARobj)
y <- SPEARobj$data$Y
df <- data.frame(Factor1 = f.scores[,1],
Factor2 = f.scores[,2],
Factor3 = f.scores[,3],
Factor4 = f.scores[,4],
Factor5 = f.scores[,5], # Assuming 5 factors were used
spear.preds = unname(spear.preds$predictions),
GausResponse = y)
plots <- list()
# Versus the predicted values from SPEAR:
for(k in 1:SPEARobj$params$num_factors){
g <- ggplot(df) +
geom_point(aes_string(x = paste0("Factor", k), y = "spear.preds")) +
geom_smooth(aes_string(x = paste0("Factor", k), y = "spear.preds"), method = "lm", color = "red") +
theme_bw()
plots[[k]] <- g
}
# Versus the actual response data:
for(k in 1:SPEARobj$params$num_factors){
g <- ggplot(df) +
geom_point(aes_string(x = paste0("Factor", k), y = "GausResponse")) +
geom_smooth(aes_string(x = paste0("Factor", k), y = "GausResponse"), method = "lm") +
theme_bw()
plots[[SPEARobj$params$num_factors + k]] <- g
}
cowplot::plot_grid(plotlist = plots, nrow = 2)
# Plot all factor loadings
#     plot.irrelevant.factors - should factors that aren't relevant to predicting Y be shown?
SPEAR.plot_factor_loadings(SPEARobj, plot.irrelevant.factors = TRUE)
# Can choose to plot per omic as well
#     plot.per.omic - make a different plot for each omic (matrix in X), rather than returning one plot with all features
#     return.list - return a list of ggplot2 grob objects instead of a plot.
SPEAR.plots <- SPEAR.plot_factor_loadings(SPEARobj, plot.per.omic = TRUE, plot.irrelevant.factors = TRUE, return.list = TRUE)
SPEAR.plots[[2]]
# Get the names of features contributing to relevant factors
#   cutoff - posterior probability selection cutoff, features with probabilities higher than 'cutoff' will be added to the list
#   threshold - minimum factor contribution to be deemed "relevant"
feature.list <- SPEAR.get_factor_features(SPEARobj, cutoff = .5, threshold = .01)
names(feature.list) # show relevant factors per response
# Below uses simulated data generated in the SPEAR_simulate_data.Rmd
path_to_sim_data <- getwd() # Replace with the path to the 'simulated_gaussian_data.rds' file
sim.data <- readRDS(paste0(path_to_sim_data, "/simulated_gaussian_data.rds"))
Xtest <- sim.data$data.te$xlist # replace with your testing data here
Ytest <- sim.data$data.te$Y     # replace with your testing data response if you have it here
# Make sure the dimensions of the test data match the dimensions of the training data
sapply(SPEARobj$data$xlist, ncol)
sapply(Xtest, ncol)
# Get predictions:
SPEARpreds <- SPEAR.predict_new_samples(SPEARobj, Xtest, scale.x = TRUE)
# Below is the same thing in case you want to work directly with the matrices:
#SPEARpreds <- scale(data.total$data.te$X) %*% SPEARobj$cv.eval$reg_coefs[,1,,which.min(SPEARobj$cv.eval$cvm)] + SPEARobj$cv.eval$intercepts[[1]][which.min(SPEARobj$cv.eval$cvm),]
SPEARpreds <- SPEARpreds$predictions
truth <- Ytest
# Plot predictions:
g <- ggplot() +
geom_point(aes(x = SPEARpreds, y = truth)) +
geom_smooth(aes(x = SPEARpreds, y = truth), method = "lm") +
xlab("SPEAR Predictions") +
ylab("True Response") +
theme_bw()
g
remotes::install_github("jgygi/SPEAR@master")
remotes::install_github("jgygi/SPEAR@main")
library(SPEARcomplete)
setwd("~/Documents/Coding/IMPACC/SPEAR/package/")
usethat::use_vignette("introduction")
install.packages("usethat")
devtools::use_vignette("introduction")
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
sessionInfo()
remotes::install_github("jgygi/SPEAR@main")
library(SPEARcomplete)
remotes::install_github("jgygi/SPEAR@main", build_vignettes = TRUE)
remotes::install_github("jgygi/SPEAR@main", build_vignettes = TRUE, force = TRUE)
browseVignettes("SPEARcomplete")
remotes::install_github(build_vignettes = TRUE)
remotes::install_github("jgygi/SPEAR@main", build_vignettes = TRUE)
browseVignettes("SPEARcomplete")
devtools::build_vignettes(SPEARcomplete)
devtools::build_vignettes("SPEARcomplete")
devtools::build_vignettes()
devtools::build_vignettes("SPEARcomplete")
getwd()
usethis::use_vignette("my-vignette")
warnings()
plot(1:10,1:10)
remotes::install_github("jgygi/SPEAR@main", build_vignettes = TRUE)
browseVignettes("SPEARcomplete")
# Check values of 'w' (weights) used by SPEAR:
SPEARobj$params$weights
# Required Packages for SPEAR:
library(SPEARcomplete)
library(glmnet)
library(parallel)
# Recommended Packages (for downstream analysis):
path_to_SPEARkit <- "~/Dropbox/shared_folder/SPEARkit/SPEARkit.R"
source(path_to_SPEARkit)
library(jsonlite)
library(dplyr)
library(reshape2)
library(stringr)
library(ggplot2)
library(cowplot)
# Load in the SPEARobject saved from running SPEAR:
file.path <- getwd()
SPEARobj <- readRDS(paste0(file.path, "/SPEAR_vignette_object.rds"))
names(SPEARobj)
# Check values of 'w' (weights) used by SPEAR:
SPEARobj$params$weights
# Get best weights (w):
#      Parameters:
# include.best.overall (only useful with more than one response... if two responses perform best with different values of w, select the single w with minimized cvm for all responses)
SPEAR.get_best_weights(SPEARobj, include.best.overall = TRUE)
# Get factor contributions for each factor generated by SPEAR. Will return:
#   factor.contributions: the exact contribution amounts per factor
#   relevant.factors:     which factors are deemed "relevant" (contribution > threshold, .01 by default)
#   threshold:   the cutoff used to determine which factors are "relevant"
SPEAR.get_factor_contributions(SPEARobj, threshold = .01)
# Plot factor contributions:
#     threshold: cutoff used to determine factor relevance
#     show.irrelevant: if FALSE, will only plot relevant factor contributions
#     show.labels: show numeric contributions in plot?
SPEAR.plot_factor_contributions(SPEARobj, threshold = .01, show.irrelevant = FALSE, show.labels = TRUE)
# As a quick aside, plotting functions all return ggplot grob objects, and can be easily edited as such:
plot <- SPEAR.plot_factor_contributions(SPEARobj, threshold = .01, show.irrelevant = FALSE, show.labels = TRUE)
plot +
scale_fill_distiller(palette = "Reds", direction = 1) +
ggtitle("Custom Factor Contribution Plot")
# Get cross-validated prediction error
#    show.all.w - show cvm for all weights? Best weight is found by lowest cvm
#  (similar to SPEARobj$cv.eval$cvm)
SPEAR.get_cv_prediction_error(SPEARobj, show.all.w = TRUE)
# Plot cv predictions for the best weight:
SPEAR.plot_cv_predictions(SPEARobj)
# Get actual predictions:
#  w - which weight to use?
#  'best' will return lowest cvm per response.
#  'overall' returns the lowest cvm overall. When only measuring one response, 'best' is the same as 'overall'.
#  'all' returns a list with each prediction for each value of 'w'.
spear.predictions.best <- SPEAR.get_cv_predictions(SPEARobj, w = "best")
spear.predictions.overall <- SPEAR.get_cv_predictions(SPEARobj, w = "all")
spear.predictions.all <- SPEAR.get_cv_predictions(SPEARobj, w = "all")
print(spear.predictions.best$predictions[1:10])
# First, set up a named vector called 'groups'. Set names(groups) to be the subject for each grouping variable:
# Example of setting up a continuous 'groups' vector:
# Use the response as the variable we want to plot:
groups <- SPEARobj$data$Y
# Set the names of the vector to be the samples they correspond to (make sure they are ordered correctly)
names(groups) <- rownames(SPEARobj$data$Y)
# Plot the factor scores:
SPEAR.plot_factor_scores(SPEARobj, groups = groups)
# Plot cv predictions for the best weight:
SPEAR.plot_cv_predictions(SPEARobj)
# Plot cv predictions for the best weight:
SPEAR.plot_cv_predictions(SPEARobj)
# Plot cv predictions for the best weight:
SPEAR.plot_cv_predictions(SPEARobj)
# Plot cv predictions for the best weight:
SPEAR.plot_cv_predictions(SPEARobj)
# Plot cv predictions for the best weight:
SPEAR.plot_cv_predictions(SPEARobj)
# Plot cv predictions for the best weight:
SPEAR.plot_cv_predictions(SPEARobj)
# Plot cv predictions for the best weight:
SPEAR.plot_cv_predictions(SPEARobj)
# Plot cv predictions for the best weight:
SPEAR.plot_cv_predictions(SPEARobj)
# Lets convert the continuous response into ordinal (bins)
# Use the response as the variable we want to plot:
groups <- round(SPEARobj$data$Y, 0)
groups <- factor(as.character(groups), levels = as.character(unique(sort(groups))))
# Set the names of the vector to be the samples they correspond to (make sure they are ordered correctly)
names(groups) <- rownames(SPEARobj$data$Y)
# Plot the factor scores:
SPEAR.plot_factor_scores(SPEARobj, groups = groups)
SPEAR.plot_factor_grid(SPEARobj, groups = groups)
SPEAR.plot_factor_grid(SPEARobj, groups = groups)
relevant.factors.to.Y <- which(SPEAR.get_factor_contributions(SPEARobj)$relevant.factors == 1)
SPEAR.plot_factor_grid(SPEARobj, groups = groups, factors = relevant.factors.to.Y)
# First, set up a named vector called 'groups'. Set names(groups) to be the subject for each grouping variable:
# Example of setting up a continuous 'groups' vector:
# Use the response as the variable we want to plot:
groups <- SPEARobj$data$Y
# Set the names of the vector to be the samples they correspond to (make sure they are ordered correctly)
names(groups) <- rownames(SPEARobj$data$Y)
# Plot the factor scores:
SPEAR.plot_factor_scores(SPEARobj, groups = groups)
# First, set up a named vector called 'groups'. Set names(groups) to be the subject for each grouping variable:
# Example of setting up a continuous 'groups' vector:
# Use the response as the variable we want to plot:
groups <- SPEARobj$data$Y
# Set the names of the vector to be the samples they correspond to (make sure they are ordered correctly)
names(groups) <- rownames(SPEARobj$data$Y)
# Plot the factor scores:
SPEAR.plot_factor_scores(SPEARobj, groups = groups)
# Lets convert the continuous response into ordinal (bins)
# Use the response as the variable we want to plot:
groups <- round(SPEARobj$data$Y, 0)
groups <- factor(as.character(groups), levels = as.character(unique(sort(groups))))
# Set the names of the vector to be the samples they correspond to (make sure they are ordered correctly)
names(groups) <- rownames(SPEARobj$data$Y)
# Plot the factor scores:
SPEAR.plot_factor_scores(SPEARobj, groups = groups)
SPEAR.plot_factor_grid(SPEARobj, groups = groups)
SPEAR.plot_factor_grid(SPEARobj, groups = groups)
# This will plot two rows of plots:
# top row - Factor Scores (X axis) vs. SPEAR CV Predictions
# bottom row - Factor Scores (X axis) vs. True response (SPEARobj$data$Y)
f.scores <- SPEAR.get_factor_scores(SPEARobj)$GausResponse$factor.scores
spear.preds <- SPEAR.get_cv_predictions(SPEARobj)
y <- SPEARobj$data$Y
df <- data.frame(Factor1 = f.scores[,1],
Factor2 = f.scores[,2],
Factor3 = f.scores[,3],
Factor4 = f.scores[,4],
Factor5 = f.scores[,5], # Assuming 5 factors were used
spear.preds = unname(spear.preds$predictions),
GausResponse = y)
plots <- list()
# Versus the predicted values from SPEAR:
for(k in 1:SPEARobj$params$num_factors){
g <- ggplot(df) +
geom_point(aes_string(x = paste0("Factor", k), y = "spear.preds")) +
geom_smooth(aes_string(x = paste0("Factor", k), y = "spear.preds"), method = "lm", color = "red") +
theme_bw()
plots[[k]] <- g
}
# Versus the actual response data:
for(k in 1:SPEARobj$params$num_factors){
g <- ggplot(df) +
geom_point(aes_string(x = paste0("Factor", k), y = "GausResponse")) +
geom_smooth(aes_string(x = paste0("Factor", k), y = "GausResponse"), method = "lm") +
theme_bw()
plots[[SPEARobj$params$num_factors + k]] <- g
}
cowplot::plot_grid(plotlist = plots, nrow = 2)
# Plot all factor loadings
#     plot.irrelevant.factors - should factors that aren't relevant to predicting Y be shown?
SPEAR.plot_factor_loadings(SPEARobj, plot.irrelevant.factors = TRUE)
# Plot all factor loadings
#     plot.irrelevant.factors - should factors that aren't relevant to predicting Y be shown?
SPEAR.plot_factor_loadings(SPEARobj, plot.irrelevant.factors = TRUE)
# Plot all factor loadings
#     plot.irrelevant.factors - should factors that aren't relevant to predicting Y be shown?
SPEAR.plot_factor_loadings(SPEARobj, plot.irrelevant.factors = TRUE)
# Can choose to plot per omic as well
#     plot.per.omic - make a different plot for each omic (matrix in X), rather than returning one plot with all features
#     return.list - return a list of ggplot2 grob objects instead of a plot.
SPEAR.plots <- SPEAR.plot_factor_loadings(SPEARobj, plot.per.omic = TRUE, plot.irrelevant.factors = TRUE, return.list = TRUE)
SPEAR.plots[[2]]
# Can choose to plot per omic as well
#     plot.per.omic - make a different plot for each omic (matrix in X), rather than returning one plot with all features
#     return.list - return a list of ggplot2 grob objects instead of a plot.
SPEAR.plots <- SPEAR.plot_factor_loadings(SPEARobj, plot.per.omic = TRUE, plot.irrelevant.factors = TRUE, return.list = TRUE)
SPEAR.plots[[2]]
# Get the names of features contributing to relevant factors
#   cutoff - posterior probability selection cutoff, features with probabilities higher than 'cutoff' will be added to the list
#   threshold - minimum factor contribution to be deemed "relevant"
feature.list <- SPEAR.get_factor_features(SPEARobj, cutoff = .5, threshold = .01)
names(feature.list) # show relevant factors per response
# Below uses simulated data generated in the SPEAR_simulate_data.Rmd
path_to_sim_data <- getwd() # Replace with the path to the 'simulated_gaussian_data.rds' file
sim.data <- readRDS(paste0(path_to_sim_data, "/simulated_gaussian_data.rds"))
Xtest <- sim.data$data.te$xlist # replace with your testing data here
Ytest <- sim.data$data.te$Y     # replace with your testing data response if you have it here
# Make sure the dimensions of the test data match the dimensions of the training data
sapply(SPEARobj$data$xlist, ncol)
sapply(Xtest, ncol)
# Get predictions:
SPEARpreds <- SPEAR.predict_new_samples(SPEARobj, Xtest, scale.x = TRUE)
# Below is the same thing in case you want to work directly with the matrices:
#SPEARpreds <- scale(data.total$data.te$X) %*% SPEARobj$cv.eval$reg_coefs[,1,,which.min(SPEARobj$cv.eval$cvm)] + SPEARobj$cv.eval$intercepts[[1]][which.min(SPEARobj$cv.eval$cvm),]
SPEARpreds <- SPEARpreds$predictions
truth <- Ytest
# Plot predictions:
g <- ggplot() +
geom_point(aes(x = SPEARpreds, y = truth)) +
geom_smooth(aes(x = SPEARpreds, y = truth), method = "lm") +
xlab("SPEAR Predictions") +
ylab("True Response") +
theme_bw()
g
remotes::install_github("jgygi/SPEAR@main", build_vignettes = TRUE)
vignette(package = "SPEARcomplete")
vignette("SPEAR_downstream_vignette", package = "SPEARcomplete")
browseVignettes("SPEARcomplete")
vignette("SPEAR_downstream_vignette")
remotes::install_github("jgygi/SPEAR@main", build_vignettes = TRUE)
vignette("SPEAR_running_spear")
